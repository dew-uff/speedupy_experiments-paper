Estou executando uma pesquisa, na qual executo 3 experimentos num ambiente Linux, que são chamados através do arquivo shell script em anexo. Nesse script, eu chamo um experimento por vez  (definidos de DESTINATIONS_0 A DESTINATIONS_3) e sequencialmente eles são executados 3 vezes com cada uma das 5 entradas para cada experimento (as 5 entradas definidas em ARGUMENTS_0 são as entradas do experimento definido no DESTINATIOS_0, as 5 entradas definidas em ARGUMENTS_1 são as entradas do experimento definido no DESTINATIOS_1 e assim suscessivamente até ARGUMENTS_2 que são as entradas do experimento definido no DESTINATION_2. Quando existirem mais experimentos no futuro, seguirá a mesma lógica). Eu repito esse processo em 4 técnicas diferentes que estou testando, onde cada uma das técnicas gera um arquivo txt de saída, que termina, respectivamente com as seguintes palavras, após o nome do próprio experimento: "_output_no_cache.txt" para a primeira técnica, "_output_spdpy_intra_args.txt" para a segunda técnica, "_output_spdpy_intra_exec.txt" para a terceira técnica e "_output_spdpy_intra_exp.txt" para a quarta técnica. Ou seja, neste caso, no final terei 12 arquivos txt, 4 para cada experimento (são 3 experimentos), cada arquivo com 15 linhas que registram o tempo de execução para cada entrada (são 5 entradas que rodaram 3x).

Tudo está funcionando perfeitamente, mas agora eu quero mudar a forma de execução. Ao invés de rodar 3x o experimento DESTINATIONS_0 com a primeira entrada de ARGUMENTS_0, depois rodar novamente 3x o experimento DESTINATIONS_0 com a segunda entrada de ARGUMENTS_0 e assim suscessivamente até a quinta entrada, para depois passar para o experimento DESTINATIONS_1 que começa novamente a rodar 3x com a primeira entrada até a quinta, agora eu quero mudar o shell script para rodar o experimento DESTINATIONS_0 uma primeira vez com a primeira entrada de ARGUMENTS_0, depois o experimento DESTINATIONS_1 uma primeira vez com a primeira entrada de ARGUMENTS_1 e assim suscessivamente até o experimento DESTINATIONS_2 uma primeira vez com a primeira entrada de ARGUMENTS_2. Ou seja, eu rodo todos os experimentos uma primeira vez com a primeira entrada, depois todos os experimentos uma primeira vez com a segunda entrada e assim por diante até a quinta entrada. Depois começo a segunda rodada, com a mesma lógica, ou seja, eu rodo todos os experimentos uma primeira vez com a primeira entrada, depois todos os experimentos uma primeira vez com a segunda entrada e assim por diante até a quinta entrada. Até chegar a última rodada de execução (neste caso são 3 rodadas). Executo isso para o primeiro método avaliado, depois o segundo, depois o terceiro e depois o quarto (Execution mode: no-cache com "python3.12 $PYTHON_FILE $(echo "$ARG") --exec-mode no-cache" e depois os três modos que eu rodo com Execution mode: manual with $ARG com python3.12 $PYTHON_FILE $(echo "$ARG") --exec-mode manual), 

Pode ver que da forma atual, eu rodo os modos no-cache (saída "_output_no_cache.txt") e intra_args (saída "_output_spdpy_intra_args.txt") no mesmo for. Acho que ficaria melhor separar os os quatro modos em 4 for diferentes, além de implementar o que eu pedi. Perceba que há uma sutil diferença entre os 3 modos que não são o no-cache (Execution mode: manual with...). O segundo modo (manual intra-args) o cache é testado dentro do argumento (entrada), assim, a pasta .speedupy deve ser apagado quando muda de argumento. Por exemplo, da forma anterior do shell script, eu apagava a pasta .speedupy somente quando eu mudava da primeira para a segunda entrada, por exemplo, para cada experimento. Isso vai trazer uma boa mudança com esta alteração de alternância que estou pedindo. 

O modo 3 é simples, é o "intra-exec", ou seja, o cache é aproveitado apenas dentro da própria execução do experimento para aquela entrada para aquela rodada, ou seja, toda vez que vai rodar um experimento precisa executar o "speedupy/setup_exp/setup.py" antes da execução e após a execução e gravação do resultado do tempo de execução no arquivo txt a pasta .speedupy é apagada com rm -rf, neste caso não precisa garantir isolamento e pode usar um único .speedupy. O modo 4 é o "intra-exp", ou seja, o cache .speedupy deve permanecer para todo o experimento, todas as entradas, mas quando eu termino todas as entradas o cache pode ser apagado, pois na próxima rodada, quando for executar novamente o experimento com a primeira entrada o cache deve estar vazio. Vamos tentar?

run_alter_v1_ds.sh

Tenho quatro arquivos diferentes para cada experimento que rodo (3 experimentos). Crie um script em python que cria um gráfico para cada experimento utilizando matplotlib que lê os arquivos numa pasta "outputs" e constrói um gráfico de linhas com 4 linhas, onde cada linha na horizontal, cada uma com uma cor diferente, representa um das 4 técnicas utilizadas. Os gráficos devem ser salvos no formato jpg numa pasta "graphs". Os pontos que ligam a linha e que devem estar representados no eixo x (o eixo y é o tempo, que é a medida da execução) são as medianas das 3 execuções em cada entrada. O shell script (.sh) que executo para gerar esses arquivos txt segue em anexo e segue também os arquivos txt de dois dos experimentos para você ler e analisar. Em cada arquivo txt temos 15 pontos de medida de tempo em segundos, pois são 5 entradas, conforme arquivo .sh em anexo, e 3 execuções, assim os 15 pontos.  A mediana deve ser calculada entre os 3 pontos de uma das 5 entradas, porém, cabe ressaltar que a execução foi alternada, assim, a linha 1 tem a execução 1 da entrada 1 do experimento, a linha 2 tem a execução 1 da entrada 2, a linha 3 tem a execução 1 da entrada 3 até a entrada 5. A linha 6 tem a execução 2 da entrada 1 do experimento, a linha 7 tem a execução 2 da entrada 2 e assim por diante. Pode me ajudar?
